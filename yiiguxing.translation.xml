<application>
  <component name="AppStorage">
    <histories>
      <item value="right Curly Check" />
      <item value="rightCurlyCheck" />
      <item value="Possible null pointer dereference There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can't ever be executed; deciding that is beyond the ability of FindBugs." />
      <item value="Bad comparison of nonnegative value with negative constant or zero This code compares a value that is guaranteed to be non-negative with a negative constant or zero." />
      <item value="Nullcheck of value previously dereferenced A value is checked here to see whether it is null, but this value can't be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous." />
      <item value="Class inherits equals() and uses Object.hashCode() This class inherits equals(Object) from an abstract superclass, and hashCode() from java.lang.Object (which returns the identity hash code, an arbitrary value assigned to the object by the VM).  Therefore, the class is very likely to violate the invariant that equal objects must have equal hashcodes. If you don't want to define a hashCode method, and/or don't believe the object will ever be put into a HashMap/Hashtable, define the hashCode() method to throw UnsupportedOperationException." />
      <item value="Useless object created Our analysis shows that this object is useless. It's created and modified, but its value never go outside of the method or produce any side-effect. Either there is a mistake and object was intended to be used or it can be removed. This analysis rarely produces false-positives. Common false-positive cases include: - This object used to implicitly throw some obscure exception. - This object used as a stub to generalize the code. - This object used to hold strong references to weak/soft-referenced objects." />
      <item value="Dead store to local variable This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. Note that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives." />
      <item value="Field is a mutable collection A mutable collection instance is assigned to a final static field, thus can be changed by malicious code or by accident from another package. Consider wrapping this field into Collections.unmodifiableSet/List/Map/etc. to avoid this vulnerability." />
      <item value="May expose internal representation by returning reference to mutable object Returning a reference to a mutable object value stored in one of the object's fields exposes the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Returning a new copy of the object is better approach in many situations." />
      <item value="厝" />
      <item value="close inspection on the fly" />
      <item value="bamboo" />
      <item value="Using a deprecated class or method is prohibited. Note: For example, decode(String source, String encode) should be used instead of the deprecated method decode(String encodeStr). Once an interface has been deprecated, the interface provider has the obligation to provide a new one. At the same time, client programmers have the obligation to check out what its new implementation is." />
      <item value="suppress bug" />
      <item value="High Confidence Internationalization" />
      <item value="Reliance on default encoding Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly." />
      <item value="Method may fail to close stream The method creates an IO stream object, does not assign it to any fields, pass it to other methods that might close it, or return it, and does not appear to close the stream on all paths out of the method.  This may result in a file descriptor leak.  It is generally a good idea to use a finally block to ensure that streams are closed." />
      <item value="redis" />
      <item value="get To Number" />
      <item value="Main barrier code, covering the various policies" />
      <item value="/** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */" />
      <item value="/** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class {@code String}. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this {@code String} object as determined by * the {@link #equals(Object)} method, then the string from the pool is * returned. Otherwise, this {@code String} object is added to the * pool and a reference to this {@code String} object is returned. * &lt;p&gt; * It follows that for any two strings {@code s} and {@code t}, * {@code s.intern() == t.intern()} is {@code true} * if and only if {@code s.equals(t)} is {@code true}. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */" />
      <item value="less than Character.MIN_RADIX" />
      <item value="/** * Parses the string argument as a signed integer in the radix * specified by the second argument. The characters in the string * must all be digits of the specified radix (as determined by * whether {@link java.lang.Character#digit(char, int)} returns a * nonnegative value), except that the first character may be an * ASCII minus sign {@code '-'} ({@code '\u005Cu002D'}) to * indicate a negative value or an ASCII plus sign {@code '+'} * ({@code '\u005Cu002B'}) to indicate a positive value. The * resulting integer value is returned. * * &lt;p&gt;An exception of type {@code NumberFormatException} is * thrown if any of the following situations occurs: * &lt;ul&gt; * &lt;li&gt;The first argument is {@code null} or is a string of * length zero. * * &lt;li&gt;The radix is either smaller than * {@link java.lang.Character#MIN_RADIX} or * larger than {@link java.lang.Character#MAX_RADIX}. * * &lt;li&gt;Any character of the string is not a digit of the specified * radix, except that the first character may be a minus sign * {@code '-'} ({@code '\u005Cu002D'}) or plus sign * {@code '+'} ({@code '\u005Cu002B'}) provided that the * string is longer than length 1. * * &lt;li&gt;The value represented by the string is not a value of type * {@code int}. * &lt;/ul&gt; * * &lt;p&gt;Examples: * &lt;blockquote&gt;&lt;pre&gt; * parseInt(&quot;0&quot;, 10) returns 0 * parseInt(&quot;473&quot;, 10) returns 473 * parseInt(&quot;+42&quot;, 10) returns 42 * parseInt(&quot;-0&quot;, 10) returns 0 * parseInt(&quot;-FF&quot;, 16) returns -255 * parseInt(&quot;1100110&quot;, 2) returns 102 * parseInt(&quot;2147483647&quot;, 10) returns 2147483647 * parseInt(&quot;-2147483648&quot;, 10) returns -2147483648 * parseInt(&quot;2147483648&quot;, 10) throws a NumberFormatException * parseInt(&quot;99&quot;, 8) throws a NumberFormatException * parseInt(&quot;Kona&quot;, 10) throws a NumberFormatException * parseInt(&quot;Kona&quot;, 27) returns 411787 * &lt;/pre&gt;&lt;/blockquote&gt; * * @param s the {@code String} containing the integer * representation to be parsed * @param radix the radix to be used while parsing {@code s}. * @return the integer represented by the string argument in the * specified radix. * @exception NumberFormatException if the {@code String} * does not contain a parsable {@code int}. */" />
      <item value="/** * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the {@link #initialValue} method. * * @return the current thread's value of this thread-local */" />
      <item value="/** * Waits at most {@code millis} milliseconds for this thread to * die. A timeout of {@code 0} means to wait forever. * * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls * conditioned on {@code this.isAlive}. As a thread terminates the * {@code this.notifyAll} method is invoked. It is recommended that * applications not use {@code wait}, {@code notify}, or * {@code notifyAll} on {@code Thread} instances. * * @param millis * the time to wait in milliseconds * * @throws IllegalArgumentException * if the value of {@code millis} is negative * * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */" />
      <item value="/** * Removes and returns the first element from this list. * * @return the first element from this list * @throws NoSuchElementException if this list is empty */" />
      <item value="/** * Transfers a node from a condition queue onto sync queue. * Returns true if successful. * @param node the node * @return true if successfully transferred (else the node was * cancelled before signal) */" />
      <item value="/** * Removes and transfers nodes until hit non-cancelled one or * null. Split out from signal in part to encourage compilers * to inline the case of no waiters. * @param first (non-null) the first node on condition queue */" />
      <item value="Abstract Queued Synchronizer" />
      <item value="/** * Implements interruptible condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by {@link #getState}. * &lt;li&gt; Invoke {@link #release} with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled or interrupted. * &lt;li&gt; Reacquire by invoking specialized version of * {@link #acquire} with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt; */" />
      <item value="/** * Implements interruptible condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by {@link #getState}. * &lt;li&gt; Invoke {@link #release} with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled or interrupted. * &lt;li&gt; Reacquire by invoking specialized version of * {@link #acquire} with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt;" />
      <item value="* Invokes release with current state value; returns saved state. * Cancels node and throws exception on failure. * @param node the condition node for this wait * @return previous sync state" />
      <item value="Unlinks cancelled waiter nodes from condition queue. * Called only while holding lock. This is called when * cancellation occurred during condition wait, and upon * insertion of a new waiter when lastWaiter is seen to have * been cancelled. This method is needed to avoid garbage * retention in the absence of signals. So even though it may * require a full traversal, it comes into play only when * timeouts or cancellations occur in the absence of * signals. It traverses all nodes rather than stopping at a * particular target to unlink all pointers to garbage nodes * without requiring many re-traversals during cancellation * storms." />
      <item value="acquire Shared" />
      <item value="unparking" />
      <item value="cancelled" />
      <item value="indicate" />
      <item value="Insertion" />
      <item value="dequeue" />
      <item value="tail" />
      <item value="enqueue" />
      <item value="predecessor" />
      <item value="signalled" />
      <item value="track" />
      <item value="tactic" />
      <item value="spinlocks" />
      <item value="lock" />
      <item value="variant" />
    </histories>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE" />
        <option name="useTranslateGoogleCom" value="false" />
      </google-translate>
    </option>
  </component>
</application>