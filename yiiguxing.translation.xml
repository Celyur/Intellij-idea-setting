<application>
  <component name="AppStorage">
    <histories>
      <item value="A fast, lightweight and cloud-native microservices framework.  Stack Overflow | Google Group | Gitter Chat | Subreddit | Youtube Channel | Documentation | Contribution Guide |  Build Status codecovio  Why called Light 4J  Light means lightweight, lightning fast and shedding light on how to program with modern Java SE.  Why this framework  Fast and small memory footprint to lower production cost.  It is 44 times faster than the most popular microservices platform Spring Boot embedded Tomcat and use only 1/5 of memory. Here is the benchmark results compare with Spring Boot and other microservices frameworks. Here is the comparison with other Web frameworks.  Provide an embedded gateway to address cross-cutting concerns.  Plugin architecture for startup/shutdown hooks and middleware components Distributed OAuth2 JWT security verification as part of the framework Request and response validation against OpenAPI specification at runtime Metrics collected in Influxdb/Prometheus and viewed from Grafana Dashboard for both services and clients Global exception handling for runtime exception, API exception, and other checked exceptions Mask sensitive data like the credit card, sin number, etc. before logging Sanitize cross-site scripting for query parameters, request headers and body Audit to dump important info or entire request and response. Body parser to support different content types Standardized response code and messages from the configuration file Externalized configuration for all modules for the dockerized environment CORS pre-flight handler for SPA (Angular or React) from another domain Rate limiting for services that exposed outside to the Internet Service registry and discovery support direct, Consul and Zookeeper Client-side discovery and load balance to eliminate proxies A client module that is tightly integrated with Light-OAuth2 and supports traceability Design and Test driven development to increase productivity  Design OpenAPI specification and generate the service from it. The specification is also part of the framework to drive security verification and request validation at runtime.  Unit/End-to-End test stubs are generated to enable test driven approach for quality product.  Debugging within IDE just like standalone application for better developer productivity.  Built-in DevOps flow to support continuous integration to production  Dockerfile and DevOps supporting files are generated to support dockerization and continuous integration to production.  Multiple frameworks for different type of microservices  light-rest-4j is a RESTful microservice framework with OpenAPI specification for code generation and runtime security and validation light-graphql-4j is a GraphQL microservice framework that supports schema generation from IDL and plugin. light-hybrid-4j is a hybrid microservice framework that takes advantages of both monolithic and microservice architectures. light-eventuate is a messaging based microservice framework based on Kafka, event sourcing and CQRS Multiple languages support  All the open sourced frameworks are built in Java and we are working on Nodejs framework internally. In the future, we might provide Golang framework as well and all them are sharing the same eco-system and market place.  OAuth2 server, portal and services to form ecosystem  OAuth2 Server for security and Portal for production monitor and management. The portal is also a marketplace to link clients and services together.  Getting Started  There are two ways to start your project:  Light-codegen generator  You can use light-codegen to generate a working project. Currently, it supports light-rest-4j, light-graphql-4j, light-hybrid-server-4j and light-hybrid-service-4j. light-eventuate code generator is coming.  The light-codegen project README.md describes four ways to use the generator with examples.  Clone and build the light-codgen and use the codegen-cli command line utility Use docker image networknt/light-codegen to run the codegen-cli command line utility Use generate.sh from model-config repo to generate projects based on conventions. Generate code from web site with codegen-web API. (API is ready but UI needs to be built) Starting from an example project  The other way to start your project is to copy from light-example-4j.  You can find the description of these examples  Also, there are some tutorials  Debugging  To run/debug from IDE, you need to configure a Java application with main class &quot;com.networknt.server.Server&quot; and working directory is your project folder. There is no container and you are working on just a standalone Java application.  Start Server  In IDE  create a Java application that main class is com.networknt.server.Server and working directory is your project root folder. You can debug your server just like a POJO application.  From Maven  mvn exec:exec  Command Line  java -jar target/demo-0.1.0.jar Stop Server  you can use Ctrl+C to kill the server but for production use the following command  kill -s TERM &lt;pid&gt; The server has a shutdown hook and the above command allow it to clean up. For example, complete in-flight requests and close the database connections etc. If service registry and discovery is used, then the server will send shutdown event to service registry and keep processing requests for 30 seconds until all clients refreshes their local cache before shutting down.  Appreciation  Light-4j has been optimized by using open source license of JProfiler from ej-technologies. License  Light-4j and all light-*-4j frameworks are available under the Apache 2.0 license. See the LICENSE file for more info." />
      <item value="The total number of lines for a method should not be more than 80. Note: The total number of lines, including the method signature, closing brace, codes, comments" />
      <item value="prohibited" />
      <item value="use utility class" />
      <item value="utility class" />
      <item value="detects when a class or interface doses not have a package definition" />
      <item value="detects when a class or interface does not have a package definition" />
      <item value="right Curly Check" />
      <item value="rightCurlyCheck" />
      <item value="Possible null pointer dereference There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can't ever be executed; deciding that is beyond the ability of FindBugs." />
      <item value="Bad comparison of nonnegative value with negative constant or zero This code compares a value that is guaranteed to be non-negative with a negative constant or zero." />
      <item value="Nullcheck of value previously dereferenced A value is checked here to see whether it is null, but this value can't be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous." />
      <item value="Class inherits equals() and uses Object.hashCode() This class inherits equals(Object) from an abstract superclass, and hashCode() from java.lang.Object (which returns the identity hash code, an arbitrary value assigned to the object by the VM).  Therefore, the class is very likely to violate the invariant that equal objects must have equal hashcodes. If you don't want to define a hashCode method, and/or don't believe the object will ever be put into a HashMap/Hashtable, define the hashCode() method to throw UnsupportedOperationException." />
      <item value="Useless object created Our analysis shows that this object is useless. It's created and modified, but its value never go outside of the method or produce any side-effect. Either there is a mistake and object was intended to be used or it can be removed. This analysis rarely produces false-positives. Common false-positive cases include: - This object used to implicitly throw some obscure exception. - This object used as a stub to generalize the code. - This object used to hold strong references to weak/soft-referenced objects." />
      <item value="Dead store to local variable This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. Note that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives." />
      <item value="Field is a mutable collection A mutable collection instance is assigned to a final static field, thus can be changed by malicious code or by accident from another package. Consider wrapping this field into Collections.unmodifiableSet/List/Map/etc. to avoid this vulnerability." />
      <item value="May expose internal representation by returning reference to mutable object Returning a reference to a mutable object value stored in one of the object's fields exposes the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Returning a new copy of the object is better approach in many situations." />
      <item value="厝" />
      <item value="close inspection on the fly" />
      <item value="bamboo" />
      <item value="Using a deprecated class or method is prohibited. Note: For example, decode(String source, String encode) should be used instead of the deprecated method decode(String encodeStr). Once an interface has been deprecated, the interface provider has the obligation to provide a new one. At the same time, client programmers have the obligation to check out what its new implementation is." />
      <item value="suppress bug" />
      <item value="High Confidence Internationalization" />
      <item value="Reliance on default encoding Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly." />
      <item value="Method may fail to close stream The method creates an IO stream object, does not assign it to any fields, pass it to other methods that might close it, or return it, and does not appear to close the stream on all paths out of the method.  This may result in a file descriptor leak.  It is generally a good idea to use a finally block to ensure that streams are closed." />
      <item value="redis" />
      <item value="get To Number" />
      <item value="Main barrier code, covering the various policies" />
      <item value="/** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */" />
      <item value="/** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class {@code String}. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this {@code String} object as determined by * the {@link #equals(Object)} method, then the string from the pool is * returned. Otherwise, this {@code String} object is added to the * pool and a reference to this {@code String} object is returned. * &lt;p&gt; * It follows that for any two strings {@code s} and {@code t}, * {@code s.intern() == t.intern()} is {@code true} * if and only if {@code s.equals(t)} is {@code true}. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */" />
      <item value="less than Character.MIN_RADIX" />
      <item value="/** * Parses the string argument as a signed integer in the radix * specified by the second argument. The characters in the string * must all be digits of the specified radix (as determined by * whether {@link java.lang.Character#digit(char, int)} returns a * nonnegative value), except that the first character may be an * ASCII minus sign {@code '-'} ({@code '\u005Cu002D'}) to * indicate a negative value or an ASCII plus sign {@code '+'} * ({@code '\u005Cu002B'}) to indicate a positive value. The * resulting integer value is returned. * * &lt;p&gt;An exception of type {@code NumberFormatException} is * thrown if any of the following situations occurs: * &lt;ul&gt; * &lt;li&gt;The first argument is {@code null} or is a string of * length zero. * * &lt;li&gt;The radix is either smaller than * {@link java.lang.Character#MIN_RADIX} or * larger than {@link java.lang.Character#MAX_RADIX}. * * &lt;li&gt;Any character of the string is not a digit of the specified * radix, except that the first character may be a minus sign * {@code '-'} ({@code '\u005Cu002D'}) or plus sign * {@code '+'} ({@code '\u005Cu002B'}) provided that the * string is longer than length 1. * * &lt;li&gt;The value represented by the string is not a value of type * {@code int}. * &lt;/ul&gt; * * &lt;p&gt;Examples: * &lt;blockquote&gt;&lt;pre&gt; * parseInt(&quot;0&quot;, 10) returns 0 * parseInt(&quot;473&quot;, 10) returns 473 * parseInt(&quot;+42&quot;, 10) returns 42 * parseInt(&quot;-0&quot;, 10) returns 0 * parseInt(&quot;-FF&quot;, 16) returns -255 * parseInt(&quot;1100110&quot;, 2) returns 102 * parseInt(&quot;2147483647&quot;, 10) returns 2147483647 * parseInt(&quot;-2147483648&quot;, 10) returns -2147483648 * parseInt(&quot;2147483648&quot;, 10) throws a NumberFormatException * parseInt(&quot;99&quot;, 8) throws a NumberFormatException * parseInt(&quot;Kona&quot;, 10) throws a NumberFormatException * parseInt(&quot;Kona&quot;, 27) returns 411787 * &lt;/pre&gt;&lt;/blockquote&gt; * * @param s the {@code String} containing the integer * representation to be parsed * @param radix the radix to be used while parsing {@code s}. * @return the integer represented by the string argument in the * specified radix. * @exception NumberFormatException if the {@code String} * does not contain a parsable {@code int}. */" />
      <item value="/** * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the {@link #initialValue} method. * * @return the current thread's value of this thread-local */" />
      <item value="/** * Waits at most {@code millis} milliseconds for this thread to * die. A timeout of {@code 0} means to wait forever. * * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls * conditioned on {@code this.isAlive}. As a thread terminates the * {@code this.notifyAll} method is invoked. It is recommended that * applications not use {@code wait}, {@code notify}, or * {@code notifyAll} on {@code Thread} instances. * * @param millis * the time to wait in milliseconds * * @throws IllegalArgumentException * if the value of {@code millis} is negative * * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */" />
      <item value="/** * Removes and returns the first element from this list. * * @return the first element from this list * @throws NoSuchElementException if this list is empty */" />
      <item value="/** * Transfers a node from a condition queue onto sync queue. * Returns true if successful. * @param node the node * @return true if successfully transferred (else the node was * cancelled before signal) */" />
      <item value="/** * Removes and transfers nodes until hit non-cancelled one or * null. Split out from signal in part to encourage compilers * to inline the case of no waiters. * @param first (non-null) the first node on condition queue */" />
      <item value="Abstract Queued Synchronizer" />
      <item value="/** * Implements interruptible condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by {@link #getState}. * &lt;li&gt; Invoke {@link #release} with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled or interrupted. * &lt;li&gt; Reacquire by invoking specialized version of * {@link #acquire} with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt; */" />
      <item value="/** * Implements interruptible condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by {@link #getState}. * &lt;li&gt; Invoke {@link #release} with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled or interrupted. * &lt;li&gt; Reacquire by invoking specialized version of * {@link #acquire} with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt;" />
      <item value="* Invokes release with current state value; returns saved state. * Cancels node and throws exception on failure. * @param node the condition node for this wait * @return previous sync state" />
      <item value="Unlinks cancelled waiter nodes from condition queue. * Called only while holding lock. This is called when * cancellation occurred during condition wait, and upon * insertion of a new waiter when lastWaiter is seen to have * been cancelled. This method is needed to avoid garbage * retention in the absence of signals. So even though it may * require a full traversal, it comes into play only when * timeouts or cancellations occur in the absence of * signals. It traverses all nodes rather than stopping at a * particular target to unlink all pointers to garbage nodes * without requiring many re-traversals during cancellation * storms." />
      <item value="acquire Shared" />
      <item value="unparking" />
      <item value="cancelled" />
      <item value="indicate" />
      <item value="Insertion" />
      <item value="dequeue" />
      <item value="tail" />
      <item value="enqueue" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2" />
        <entry key="CHINESE_TRADITIONAL" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE" />
        <option name="useTranslateGoogleCom" value="false" />
      </google-translate>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
  </component>
</application>