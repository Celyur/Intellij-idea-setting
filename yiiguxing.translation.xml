<application>
  <component name="AppStorage">
    <histories>
      <item value="Main barrier code, covering the various policies" />
      <item value="/** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */" />
      <item value="/** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class {@code String}. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this {@code String} object as determined by * the {@link #equals(Object)} method, then the string from the pool is * returned. Otherwise, this {@code String} object is added to the * pool and a reference to this {@code String} object is returned. * &lt;p&gt; * It follows that for any two strings {@code s} and {@code t}, * {@code s.intern() == t.intern()} is {@code true} * if and only if {@code s.equals(t)} is {@code true}. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */" />
      <item value="less than Character.MIN_RADIX" />
      <item value="/** * Parses the string argument as a signed integer in the radix * specified by the second argument. The characters in the string * must all be digits of the specified radix (as determined by * whether {@link java.lang.Character#digit(char, int)} returns a * nonnegative value), except that the first character may be an * ASCII minus sign {@code '-'} ({@code '\u005Cu002D'}) to * indicate a negative value or an ASCII plus sign {@code '+'} * ({@code '\u005Cu002B'}) to indicate a positive value. The * resulting integer value is returned. * * &lt;p&gt;An exception of type {@code NumberFormatException} is * thrown if any of the following situations occurs: * &lt;ul&gt; * &lt;li&gt;The first argument is {@code null} or is a string of * length zero. * * &lt;li&gt;The radix is either smaller than * {@link java.lang.Character#MIN_RADIX} or * larger than {@link java.lang.Character#MAX_RADIX}. * * &lt;li&gt;Any character of the string is not a digit of the specified * radix, except that the first character may be a minus sign * {@code '-'} ({@code '\u005Cu002D'}) or plus sign * {@code '+'} ({@code '\u005Cu002B'}) provided that the * string is longer than length 1. * * &lt;li&gt;The value represented by the string is not a value of type * {@code int}. * &lt;/ul&gt; * * &lt;p&gt;Examples: * &lt;blockquote&gt;&lt;pre&gt; * parseInt(&quot;0&quot;, 10) returns 0 * parseInt(&quot;473&quot;, 10) returns 473 * parseInt(&quot;+42&quot;, 10) returns 42 * parseInt(&quot;-0&quot;, 10) returns 0 * parseInt(&quot;-FF&quot;, 16) returns -255 * parseInt(&quot;1100110&quot;, 2) returns 102 * parseInt(&quot;2147483647&quot;, 10) returns 2147483647 * parseInt(&quot;-2147483648&quot;, 10) returns -2147483648 * parseInt(&quot;2147483648&quot;, 10) throws a NumberFormatException * parseInt(&quot;99&quot;, 8) throws a NumberFormatException * parseInt(&quot;Kona&quot;, 10) throws a NumberFormatException * parseInt(&quot;Kona&quot;, 27) returns 411787 * &lt;/pre&gt;&lt;/blockquote&gt; * * @param s the {@code String} containing the integer * representation to be parsed * @param radix the radix to be used while parsing {@code s}. * @return the integer represented by the string argument in the * specified radix. * @exception NumberFormatException if the {@code String} * does not contain a parsable {@code int}. */" />
      <item value="/** * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the {@link #initialValue} method. * * @return the current thread's value of this thread-local */" />
      <item value="/** * Waits at most {@code millis} milliseconds for this thread to * die. A timeout of {@code 0} means to wait forever. * * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls * conditioned on {@code this.isAlive}. As a thread terminates the * {@code this.notifyAll} method is invoked. It is recommended that * applications not use {@code wait}, {@code notify}, or * {@code notifyAll} on {@code Thread} instances. * * @param millis * the time to wait in milliseconds * * @throws IllegalArgumentException * if the value of {@code millis} is negative * * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */" />
      <item value="/** * Removes and returns the first element from this list. * * @return the first element from this list * @throws NoSuchElementException if this list is empty */" />
      <item value="/** * Transfers a node from a condition queue onto sync queue. * Returns true if successful. * @param node the node * @return true if successfully transferred (else the node was * cancelled before signal) */" />
      <item value="/** * Removes and transfers nodes until hit non-cancelled one or * null. Split out from signal in part to encourage compilers * to inline the case of no waiters. * @param first (non-null) the first node on condition queue */" />
      <item value="Abstract Queued Synchronizer" />
      <item value="/** * Implements interruptible condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by {@link #getState}. * &lt;li&gt; Invoke {@link #release} with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled or interrupted. * &lt;li&gt; Reacquire by invoking specialized version of * {@link #acquire} with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt; */" />
      <item value="/** * Implements interruptible condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by {@link #getState}. * &lt;li&gt; Invoke {@link #release} with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled or interrupted. * &lt;li&gt; Reacquire by invoking specialized version of * {@link #acquire} with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt;" />
      <item value="* Invokes release with current state value; returns saved state. * Cancels node and throws exception on failure. * @param node the condition node for this wait * @return previous sync state" />
      <item value="Unlinks cancelled waiter nodes from condition queue. * Called only while holding lock. This is called when * cancellation occurred during condition wait, and upon * insertion of a new waiter when lastWaiter is seen to have * been cancelled. This method is needed to avoid garbage * retention in the absence of signals. So even though it may * require a full traversal, it comes into play only when * timeouts or cancellations occur in the absence of * signals. It traverses all nodes rather than stopping at a * particular target to unlink all pointers to garbage nodes * without requiring many re-traversals during cancellation * storms." />
      <item value="acquire Shared" />
      <item value="unparking" />
      <item value="cancelled" />
      <item value="indicate" />
      <item value="Insertion" />
      <item value="dequeue" />
      <item value="tail" />
      <item value="enqueue" />
      <item value="predecessor" />
      <item value="signalled" />
      <item value="track" />
      <item value="tactic" />
      <item value="spinlocks" />
      <item value="lock" />
      <item value="variant" />
      <item value="return" />
      <item value="Long" />
      <item value="interface" />
      <item value="City" />
    </histories>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE" />
        <option name="useTranslateGoogleCom" value="false" />
      </google-translate>
    </option>
  </component>
</application>